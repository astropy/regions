# Licensed under a 3-clause BSD style license - see LICENSE.rst

import warnings
from copy import deepcopy

from astropy.coordinates import Angle, SkyCoord
from astropy.units import Quantity

from regions.core import (PixelRegion, Region, Regions, SkyRegion)
from regions.core.registry import RegionsRegistry
from regions.io.stcs.core import (format_coordinate, region_to_stcs_shape,
                                  stcs_templates)
from regions.shapes import RegularPolygonPixelRegion

__all__ = []


@RegionsRegistry.register(Region, 'serialize', 'stcs')
@RegionsRegistry.register(Regions, 'serialize', 'stcs')
def _serialize_stcs(regions, precision=8):
    """
    Serialize regions to STC-S format.

    Parameters
    ----------
    regions : `~regions.Region` or `~regions.Regions`
        Region or regions to serialize.
    precision : int, optional
        Number of decimal places for coordinates (default: 8).

    Returns
    -------
    stcs_string : str
        STC-S formatted string.
    """
    if not regions:
        return ''

    if isinstance(regions, Region):
        regions = [regions]

    region_strings = []
    for region in regions:
        try:
            region_str = _serialize_region_stcs(region, precision=precision)
            if region_str:
                region_strings.append(region_str)
        except Exception as e:
            warnings.warn(f'Cannot serialize region {region}: {e}',
                         UserWarning)

    return '\n'.join(region_strings)


@RegionsRegistry.register(Region, 'write', 'stcs')
@RegionsRegistry.register(Regions, 'write', 'stcs')
def _write_stcs(regions, filename, precision=8, overwrite=False):
    """
    Write regions to an STC-S file.

    Parameters
    ----------
    regions : `~regions.Region` or `~regions.Regions`
        Region or regions to write.
    filename : str
        Output filename.
    precision : int, optional
        Number of decimal places for coordinates (default: 8).
    overwrite : bool, optional
        Whether to overwrite existing files (default: False).
    """
    import os

    if os.path.exists(filename) and not overwrite:
        raise OSError(f"File '{filename}' already exists. Use overwrite=True to overwrite.")

    stcs_string = _serialize_stcs(regions, precision=precision)

    with open(filename, 'w') as f:
        f.write('# STC-S region file\n')
        f.write('# Generated by astropy-regions\n')
        f.write(stcs_string)


def _serialize_region_stcs(region, precision=8):
    """
    Serialize a single region to STC-S format.

    Parameters
    ----------
    region : `~regions.Region`
        The region to serialize.
    precision : int, optional
        Number of decimal places for coordinates.

    Returns
    -------
    stcs_string : str
        STC-S formatted string for the region.
    """
    region_class_name = region.__class__.__name__

    if region_class_name not in region_to_stcs_shape:
        raise ValueError(f"Unsupported region type: {region_class_name}")

    shape_name = region_to_stcs_shape[region_class_name]

    # Handle RegularPolygonPixelRegion by converting to polygon
    if isinstance(region, RegularPolygonPixelRegion):
        region = region.to_polygon()
        shape_name = 'Polygon'

    # Determine coordinate frame and type
    is_pixel = isinstance(region, PixelRegion)
    is_sky = isinstance(region, SkyRegion)

    if is_pixel:
        frame = 'IMAGE'
        refpos = 'UNKNOWN'
        unit = 'pixel'
    elif is_sky:
        # Get frame from region's coordinate system
        if hasattr(region, 'center') and hasattr(region.center, 'frame'):
            frame_name = region.center.frame.name.upper()
            frame = {'ICRS': 'ICRS', 'FK5': 'FK5', 'FK4': 'FK4',
                    'GALACTIC': 'GALACTIC', 'GEOCENTRICTRUEECLIPTIC': 'ECLIPTIC'}.get(frame_name, 'ICRS')
        else:
            frame = 'ICRS'
        refpos = 'BARYCENTER'

        # Determine unit from region coordinates
        if hasattr(region, 'center'):
            unit = _get_coordinate_unit(region.center)
        else:
            unit = 'degree'
    else:
        raise ValueError(f"Unknown region coordinate type: {region}")

    # Serialize based on shape
    if shape_name == 'Circle':
        return _serialize_circle(region, frame, refpos, unit, precision)
    elif shape_name == 'Ellipse':
        return _serialize_ellipse(region, frame, refpos, unit, precision)
    elif shape_name == 'Box':
        return _serialize_box(region, frame, refpos, unit, precision)
    elif shape_name == 'Polygon':
        return _serialize_polygon(region, frame, refpos, unit, precision)
    elif shape_name == 'Position':
        return _serialize_position(region, frame, refpos, unit, precision)
    else:
        raise ValueError(f"Serialization not implemented for shape: {shape_name}")


def _serialize_circle(region, frame, refpos, unit, precision):
    """Serialize Circle region."""
    if isinstance(region, PixelRegion):
        center_lon = format_coordinate(region.center.x, precision)
        center_lat = format_coordinate(region.center.y, precision)
        radius = format_coordinate(region.radius, precision)
    else:
        center_lon = format_coordinate(region.center.ra.to('degree').value, precision)
        center_lat = format_coordinate(region.center.dec.to('degree').value, precision)
        radius = format_coordinate(region.radius.to('degree').value, precision)

    return f"Circle {frame} {refpos} {center_lon} {center_lat} {radius}"


def _serialize_ellipse(region, frame, refpos, unit, precision):
    """Serialize Ellipse region."""
    if isinstance(region, PixelRegion):
        center_lon = format_coordinate(region.center.x, precision)
        center_lat = format_coordinate(region.center.y, precision)
        semi_major = format_coordinate(region.width / 2, precision)
        semi_minor = format_coordinate(region.height / 2, precision)
        angle = format_coordinate(region.angle.to('degree').value, precision)
    else:
        center_lon = format_coordinate(region.center.ra.to('degree').value, precision)
        center_lat = format_coordinate(region.center.dec.to('degree').value, precision)
        semi_major = format_coordinate((region.width / 2).to('degree').value, precision)
        semi_minor = format_coordinate((region.height / 2).to('degree').value, precision)
        angle = format_coordinate(region.angle.to('degree').value, precision)

    return f"Ellipse {frame} {refpos} {center_lon} {center_lat} {semi_major} {semi_minor} {angle}"


def _serialize_box(region, frame, refpos, unit, precision):
    """Serialize Box/Rectangle region."""
    if isinstance(region, PixelRegion):
        center_lon = format_coordinate(region.center.x, precision)
        center_lat = format_coordinate(region.center.y, precision)
        width = format_coordinate(region.width, precision)
        height = format_coordinate(region.height, precision)
        angle = format_coordinate(region.angle.to('degree').value, precision)
    else:
        center_lon = format_coordinate(region.center.ra.to('degree').value, precision)
        center_lat = format_coordinate(region.center.dec.to('degree').value, precision)
        width = format_coordinate(region.width.to('degree').value, precision)
        height = format_coordinate(region.height.to('degree').value, precision)
        angle = format_coordinate(region.angle.to('degree').value, precision)

    return f"Box {frame} {refpos} {center_lon} {center_lat} {width} {height} {angle}"


def _serialize_polygon(region, frame, refpos, unit, precision):
    """Serialize Polygon region."""
    if isinstance(region, PixelRegion):
        vertices_str = []
        for vertex in region.vertices:
            x = format_coordinate(vertex.x, precision)
            y = format_coordinate(vertex.y, precision)
            vertices_str.extend([x, y])
    else:
        vertices_str = []
        for vertex in region.vertices:
            lon = format_coordinate(vertex.ra.to('degree').value, precision)
            lat = format_coordinate(vertex.dec.to('degree').value, precision)
            vertices_str.extend([lon, lat])

    vertices_coords = ' '.join(vertices_str)
    return f"Polygon {frame} {refpos} {vertices_coords}"


def _serialize_position(region, frame, refpos, unit, precision):
    """Serialize Position/Point region."""
    if isinstance(region, PixelRegion):
        center_lon = format_coordinate(region.center.x, precision)
        center_lat = format_coordinate(region.center.y, precision)
    else:
        center_lon = format_coordinate(region.center.ra.to('degree').value, precision)
        center_lat = format_coordinate(region.center.dec.to('degree').value, precision)

    return f"Position {frame} {refpos} {center_lon} {center_lat}"


def _get_coordinate_unit(coord):
    """
    Get the unit from a SkyCoord object.

    Parameters
    ----------
    coord : `~astropy.coordinates.SkyCoord`
        Coordinate object.

    Returns
    -------
    unit : str
        Unit string.
    """
    if hasattr(coord, 'ra'):
        return coord.ra.unit.to_string()
    elif hasattr(coord, 'lon'):
        return coord.lon.unit.to_string()
    else:
        return 'degree'
